/*
* AUTO-GENERATED FILE - DO NOT MODIFY
*
* This SQL file was generated by a code generation tool. Any modifications
* made to this file may be overwritten by subsequent code generation
* processes and could lead to inconsistencies or errors in the application.
*
* For any required changes, please modify the source templates or the
* code generation tool's configurations and regenerate this file.
*
* WARNING: MODIFYING THIS FILE DIRECTLY CAN LEAD TO UNEXPECTED BEHAVIOR
* AND IS STRONGLY DISCOURAGED.
*/
create type deribit.private_get_leg_prices_request_leg_direction as enum (
    'buy',
    'sell'
);

create type deribit.private_get_leg_prices_request_leg as (
    "instrument_name" text,
    "amount" double precision,
    "direction" deribit.private_get_leg_prices_request_leg_direction
);

comment on column deribit.private_get_leg_prices_request_leg."instrument_name" is '(Required) Instrument name';
comment on column deribit.private_get_leg_prices_request_leg."amount" is '(Required) It represents the requested trade size. For perpetual and inverse futures the amount is in USD units. For options and linear futures it is the underlying base currency coin.';
comment on column deribit.private_get_leg_prices_request_leg."direction" is '(Required) Direction of selected leg';

create type deribit.private_get_leg_prices_request as (
    "legs" deribit.private_get_leg_prices_request_leg[],
    "price" double precision
);

comment on column deribit.private_get_leg_prices_request."legs" is '(Required) List of legs for which the prices will be calculated';
comment on column deribit.private_get_leg_prices_request."price" is '(Required) Price for the whole leg structure';

create type deribit.private_get_leg_prices_response_leg as (
    "direction" text,
    "instrument_name" text,
    "price" double precision,
    "ratio" bigint
);

comment on column deribit.private_get_leg_prices_response_leg."direction" is 'Direction: buy, or sell';
comment on column deribit.private_get_leg_prices_response_leg."instrument_name" is 'Unique instrument identifier';
comment on column deribit.private_get_leg_prices_response_leg."price" is 'Price for a leg';
comment on column deribit.private_get_leg_prices_response_leg."ratio" is 'Ratio of amount between legs';

create type deribit.private_get_leg_prices_response_result as (
    "amount" double precision,
    "legs" deribit.private_get_leg_prices_response_leg[]
);

comment on column deribit.private_get_leg_prices_response_result."amount" is 'This value multiplied by the ratio of a leg gives trade size on that leg.';

create type deribit.private_get_leg_prices_response as (
    "id" bigint,
    "jsonrpc" text,
    "result" deribit.private_get_leg_prices_response_result
);

comment on column deribit.private_get_leg_prices_response."id" is 'The id that was sent in the request';
comment on column deribit.private_get_leg_prices_response."jsonrpc" is 'The JSON-RPC version (2.0)';

create function deribit.private_get_leg_prices(
    "legs" deribit.private_get_leg_prices_request_leg[],
    "price" double precision
)
returns deribit.private_get_leg_prices_response_result
language sql
as $$
    
    with request as (
        select row(
            "legs",
            "price"
        )::deribit.private_get_leg_prices_request as payload
    ), 
    http_response as (
        select deribit.private_jsonrpc_request(
            auth := deribit.get_auth(),
            url := '/private/get_leg_prices'::deribit.endpoint,
            request := request.payload,
            rate_limiter := 'deribit.non_matching_engine_request_log_call'::name
        ) as http_response
        from request
    )
    select (
        jsonb_populate_record(
            null::deribit.private_get_leg_prices_response,
            convert_from((a.http_response).body, 'utf-8')::jsonb
        )
    ).result
    from http_response a

$$;

comment on function deribit.private_get_leg_prices is 'This method returns individual leg prices for a given combo structure based on an aggregated price of the strategy and the mark prices of the individual legs. Please note that leg prices change dynamically with mark price fluctuations, and the algorithm is calibrated only for conventional option structures and future spreads. This method supports both inverse strategies and known linear structures within a single currency pair.';
